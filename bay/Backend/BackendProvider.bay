/*!
 *  Bayrell Core Library
 *
 *  (c) Copyright 2018-2019 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Core.Backend;

use Runtime.re;
use Runtime.ContextObject;
use Runtime.RuntimeConstant;
use Runtime.RuntimeUtils;
use Core.Http.ApiRequest;
use Core.Http.ApiResult;
use Core.Http.Request;
use Core.Http.Response;
use Core.UI.Annotations.ApiMethod;
use Core.UI.Annotations.RouteInfo;
use Core.UI.Interfaces.ApiDeclaringInterface;
use Core.UI.Interfaces.RoutesDeclaringInterface;
use Core.UI.Interfaces.RoutesInterface;
use Core.UI.Render.WebContainer;


class BackendProvider extends ContextObject
{
	
	public Vector<string> api = null;
	public Vector<string> routes = null;
	public Vector<RouteInfo> routes_info = null;
	
	
	/**
	 * Start app
	 */
	public async void start()
	{
		/* Fork context */
		ContextInterface context = this.context().fork();
		
		/* Set context values */
		context.setValue('default.app', this);
		
		#switch
		#case ifcode PHP then
		$context->setValue('root.path', ROOT_PATH);
		#endswitch
		
		/* Build */
		this.build();
		
		/* Create request */
		Request request = await this.createRequest();
		
		/* Create web container */
		WebContainer container = new WebContainer{
			"request": request,
		};
		
		/* Run app */
		container = await this.run(container, context);
		
		/* Send reponse */
		await this.sendResponse(container.response);
		
		/* Release request's context */
		context.release();
	}
	
	
	
	
	/**
	 * Build app
	 */
	public void build()
	{
		this.buildApi();
		this.buildRoutes();
		this.buildRoutesInfo();
	}
	
	
	
	/**
	 * Build routes
	 */
	public void buildApi(bool force = false)
	{
		if (this.api and not force)
			return;
		
		/* Filter modules. Leave only ApiDeclaringInterface  */
		Vector<string> modules = this.context().getModules();
		Vector<string> modules_api = modules.filter(
			bool (string module_name)
			{
				string module_description_class_name = module_name ~ ".ModuleDescription";
				Vector<string> interfaces = RuntimeUtils::getInterfaces(module_description_class_name);
				bool has_api = interfaces.indexOf( classof ApiDeclaringInterface ) != -1;
				if (not has_api) return false;
				return true;
			}
		);
		
		/* Get api names */
		this.api = modules_api.reduce(
			void (Vector<string> arr, string module_name)
			{
				string module_description_class_name = module_name ~ ".ModuleDescription";
				api = rtl::callStaticMethod(
					module_description_class_name, 
					"getApi", 
					[
						this.context()
					]
				);
				if (api == null)
					return arr;
					
				return arr.concat(api);
			}, 
			new Vector()
		);
		
	}
	
	
	
	/**
	 * Build routes
	 */
	public void buildRoutes(bool force = false)
	{
		
		if (this.routes and not force)
			return;
		
		/* Filter modules. Leave only PageDescriptionInterface  */
		Vector<string> modules = this.context().getModules();
		Vector<string> modules_pages = modules.filter(
			bool (string module_name)
			{
				string module_description_class_name = module_name ~ ".ModuleDescription";
				Vector<string> interfaces = RuntimeUtils::getInterfaces(module_description_class_name);
				bool has_api = interfaces.indexOf( classof RoutesDeclaringInterface ) != -1;
				if (not has_api) return false;
				return true;
			}
		);
		
		/* Get routes names */
		this.routes = modules_pages.reduce(
			void (Vector<string> arr, string module_name)
			{
				string module_description_class_name = module_name ~ ".ModuleDescription";
				routes = rtl::callStaticMethod(
					module_description_class_name, 
					"getRoutes", 
					[
						this.context()
					]
				);
				if (routes == null)
					return arr;
					
				return arr.concat(routes);
			}, 
			new Vector()
		);
		
	}
	
	
	
	/**
	 * Build routes info
	 */
	public void buildRoutesInfo(bool force = false)
	{
		if (this.routes_info and not force)
			return;
		
		this.routes_info = new Vector<string>();
		
		/* Analyze routes */
		if (this.routes)
		{
			this.routes.each(
				void (string class_name)
				{
					Vector<string> interfaces = RuntimeUtils::getInterfaces(class_name);
					if (interfaces == null)
						return;
					
					Vector<IntrospectionInfo> introspection = RuntimeUtils::getIntrospection(class_name);
					if (introspection == null)
						return;
					
					/* Analyze introspection */
					introspection.each(
						void (IntrospectionInfo info)
						{
							Vector<CoreObject> annotations = info::filterAnnotations(classof RouteInfo, info);
							
							if (annotations == null)
								return;
							if (annotations.count() == 0)
								return;
							
							RouteInfo route_info = annotations.item(0);
							route_info = route_info.copy({
								"class_name": info.class_name,
								"method_name": info.name,
							});
							
							
							this.routes_info.push(route_info);
						}
					);
				}
			);
		}
		
	}
	
	
	/**
	 * Send response
	 * @return Response res
	 */
	public async Request createRequest()
	{
		Request r = null;
		
		#switch
		#case ifcode PHP then
		$host = isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : "";
		$uri = isset($_SERVER['REQUEST_URI']) ? $_SERVER['REQUEST_URI'] : "";
		$method = isset($_SERVER['REQUEST_METHOD']) ? $_SERVER['REQUEST_METHOD'] : "";
		$start_time = isset($_SERVER['REQUEST_TIME_FLOAT']) ? $_SERVER['REQUEST_TIME_FLOAT'] : "";
		$query = new Map();
		$payload = new Map();
		$cookies = new Map();
		foreach ($_GET as $key => $val) $query->set($key, $val);
		foreach ($_POST as $key => $val){
			$payload->set($key, RuntimeUtils::NativeToObject($val));
		}
		foreach ($_COOKIE as $key => $val) $cookies->set($key, $val);
		
		$arr = parse_url($uri);
		$uri = isset($arr['path']) ? $arr['path'] : "";
		
		$r = new Request(
			new Map([
				"host" => $host,
				"uri" => $uri,
				"method" => $method,
				"query" => $query->toDict(),
				"payload" => $payload->toDict(),
				"cookies" => $cookies->toDict(),
				"start_time" => $start_time,
			])
		);
		
		#endswitch
		
		return r;
	}
	
	
	
	/**
	 * Run request
	 */
	public async WebContainer run(WebContainer container, ContextInterface context)
	{
		container = await this.startRequest(container);
		container = await this.beforeFoundRoute(container);
		container = await this.findRoute(container);
		container = await this.afterFoundRoute(container);
		container = await this.beforeRenderPage(container);
		container = await this.renderPage(container, context);
		container = await this.afterRenderPage(container);
		return container;
	}
	
	
	
	/**
	 * Start request
	 * @params Request req
	 */
	public async WebContainer startRequest(WebContainer container)
	{
		return container;
	}
	
	
	
	/**
	 * Before found route
	 * @params Request req
	 */
	public async WebContainer beforeFoundRoute(WebContainer container)
	{
		return container;
	}
	
	
	
	/**
	 * Find route
	 * @params Request req
	 */
	public async WebContainer findRoute(WebContainer container)
	{
		for (int i=0; i<this.routes_info.count(); i++)
		{
			RouteInfo info = this.routes_info.item(i);
			Collection<string> matches = re::matchAll( info.uri_match, container.request.uri );
			
			if (matches != null)
			{
				matches = matches.map(
					string (Collection<string> arr)
					{
						return arr.get(0, "");
					}
				);
				Dict<string> params = info::getParams(matches, info);
				container = container.copy({ "params": params, "route_info": info });
				return container;
			}
		}
		
		return container;
	}
	
	
	
	/**
	 * After found route
	 * @params Request req
	 */
	public async void afterFoundRoute(WebContainer container)
	{
		if (container.route_info == null)
		{
			Response response = new Response{
				"http_code": 404,
				"content": "<h1>Page not found</h1>",
			};
			container <= response <= response;
			/*container = container.copy({ "response": response });*/
		}		
		return container;
	}
	
	
	
	/**
	 * Before render
	 * @params Request req
	 */
	public async void beforeRenderPage(WebContainer container)
	{
		return container;
	}
	
	
	
	/**
	 * Find route
	 * @params Request req
	 */
	public async WebContainer renderPage(WebContainer container, ContextInterface context)
	{
		if (container.response) return container;
		if (container.route_info == null) return container;
		
		/* If route is exists */
		if ( not rtl::class_exists (container.route_info.class_name) )
		{
			return container;
		}
		
		/* Call before method */
		callback f = rtl::method(container.route_info.class_name, "before");
		container = await f(container, container.route_info.method_name, context);
		
		/* If has response */
		if (container.response) 
		{
			return container;
		}
		
		/* Call route */
		/*container = (method (container.route_info.class_name, container.route_info.method_name)) ([ container ]);*/
		callback f = rtl::method(container.route_info.class_name, container.route_info.method_name);
		container = await f(container, context);
		
		/* Call after method */
		callback f = rtl::method(container.route_info.class_name, "after");
		container = await f(container, container.route_info.method_name, context);
		
		return container;
	}
	
	
	
	/**
	 * After render
	 * @params Request req
	 */
	public async void afterRenderPage(WebContainer container)
	{
		return container;
	}
	
	
	
	/**
	 * Send response
	 * @param Response res
	 */
	public async void sendResponse(Response res)
	{
		if (res == null) 
			return;
			
		#switch
		#case ifcode PHP then
		http_response_code($res->http_code);
		if ($res->headers != null)
		{
			$res->headers->each(function ($key, $value){
				header($key . ": " . $value, true);
			});
		}
		if ($res->cookies != null)
		{
			$res->cookies->each(function ($key, $item){
				setcookie($item->name, $item->value, $item->expire, $item->path);
			});
		}
		echo $res->getContent();
		#endswitch
	}
	
	
	
	/**
	 * Check if api is exists
	 */
	public async ApiResult callApi
	(
		string class_name, string interface_name, string method_name, 
		Dict<mixed> data, ContextInterface context
	)
	{
		/* Check if class name is api */
		if (this.api.indexOf(class_name) == -1)
		{
			return ApiResult::setError(
				new ApiResult(),
				RuntimeConstant::ERROR_OBJECT_DOES_NOT_EXISTS, 
				"Class " ~ class_name ~ " does not exists in api list"
			);
		}
		
		/* Check if class name is exists */
		else if (not rtl::class_exists(class_name))
		{
			return ApiResult::setError(
				new ApiResult(),
				RuntimeConstant::ERROR_OBJECT_DOES_NOT_EXISTS, 
				"Class " ~ class_name ~ " does not exists"
			);
		}
		
		/* Find api method */
		string find_method_name = "";
		ApiMethod find_api_method = null;
		Vector<IntrospectionInfo> introspection = RuntimeUtils::getIntrospection(class_name);
		for (int i=0; i<introspection.count(); i++)
		{
			IntrospectionInfo info = introspection.item(i);
			if (info.kind != "method") continue;
			
			Vector<CoreObject> annotations = info::filterAnnotations(classof ApiMethod, info);
			if (annotations == null) continue;
			if (annotations.count() == 0) continue;
			
			ApiMethod api_method = annotations.item(0);
			if (api_method.space == interface_name and api_method.name == method_name)
			{
				find_api_method = api_method;
				find_method_name = info.name;
				break;
			}
		}
		
		if (find_api_method == null)
		{
			return ApiResult::setError(
				new ApiResult(),
				RuntimeConstant::ERROR_OBJECT_DOES_NOT_EXISTS, 
				"Method " ~ class_name ~ "." ~ interface_name ~ "." ~ method_name ~ " does not exists"
			);
		}
		
		callback f = rtl::method(class_name, find_method_name);
		ApiRequest request = new ApiRequest{ "data": data };
		ApiResult res = await f(context, request);
		
		return res;
	}
	
	
}

